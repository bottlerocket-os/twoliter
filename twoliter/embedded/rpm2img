#!/usr/bin/env bash
# shellcheck disable=SC2154  # variables are defined externally by the environment

set -eu -o pipefail
shopt -qs failglob

# import the partition helper functions
# shellcheck source=partyplanner
. "${0%/*}/partyplanner"

OUTPUT_FMT="raw"
OVF_TEMPLATE=""

GRUB_SET_PRIVATE_VAR="no"
XFS_DATA_PARTITION="no"
UEFI_SECURE_BOOT="no"

SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}"

for opt in "$@"; do
   optarg="$(expr "${opt}" : '[^=]*=\(.*\)')"
   case "${opt}" in
      --package-dir=*) PACKAGE_DIR="${optarg}" ;;
      --output-dir=*) OUTPUT_DIR="${optarg}" ;;
      --output-fmt=*) OUTPUT_FMT="${optarg}" ;;
      --os-image-size-gib=*) OS_IMAGE_SIZE_GIB="${optarg}" ;;
      --data-image-size-gib=*) DATA_IMAGE_SIZE_GIB="${optarg}" ;;
      --os-image-publish-size-gib=*) OS_IMAGE_PUBLISH_SIZE_GIB="${optarg}" ;;
      --data-image-publish-size-gib=*) DATA_IMAGE_PUBLISH_SIZE_GIB="${optarg}" ;;
      --partition-plan=*) PARTITION_PLAN="${optarg}" ;;
      --ovf-template=*) OVF_TEMPLATE="${optarg}" ;;
      --with-grub-set-private-var=*) GRUB_SET_PRIVATE_VAR="${optarg}" ;;
      --xfs-data-partition=*) XFS_DATA_PARTITION="${optarg}" ;;
      --with-uefi-secure-boot=*) UEFI_SECURE_BOOT="${optarg}" ;;
   esac
done

# import the image helper functions
# shellcheck source=imghelper
. "${0%/*}/imghelper"

sanity_checks \
  "${OUTPUT_FMT}" "${PARTITION_PLAN}" "${OVF_TEMPLATE}" "${UEFI_SECURE_BOOT}"

# Store output artifacts in a versioned directory.
OUTPUT_DIR="${OUTPUT_DIR}/${VERSION_ID}-${BUILD_ID}"
mkdir -p "${OUTPUT_DIR}"

FILENAME_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-${VERSION_ID}-${BUILD_ID}"
OS_IMAGE_NAME="${FILENAME_PREFIX}"
DATA_IMAGE_NAME="${FILENAME_PREFIX}-data"
BOOT_IMAGE_NAME="${FILENAME_PREFIX}-boot.ext4.lz4"
VERITY_IMAGE_NAME="${FILENAME_PREFIX}-root.verity.lz4"
ROOT_IMAGE_NAME="${FILENAME_PREFIX}-root.ext4.lz4"

OS_IMAGE="$(mktemp)"
BOOT_IMAGE="$(mktemp)"
VERITY_IMAGE="$(mktemp)"
ROOT_IMAGE="$(mktemp)"
DATA_IMAGE="$(mktemp)"
EFI_IMAGE="$(mktemp)"
PRIVATE_IMAGE="$(mktemp)"
BOTTLEROCKET_DATA="$(mktemp)"

ROOT_MOUNT="$(mktemp -d)"
BOOT_MOUNT="$(mktemp -d)"
DATA_MOUNT="$(mktemp -d)"
EFI_MOUNT="$(mktemp -d)"
PRIVATE_MOUNT="$(mktemp -d)"

SBKEYS="${HOME}/sbkeys"

SELINUX_ROOT="/etc/selinux"
SELINUX_POLICY="fortified"
SELINUX_FILE_CONTEXTS="${ROOT_MOUNT}/${SELINUX_ROOT}/${SELINUX_POLICY}/contexts/files/file_contexts"

VERITY_VERSION=1
VERITY_HASH_ALGORITHM=sha256
VERITY_DATA_BLOCK_SIZE=4096
VERITY_HASH_BLOCK_SIZE=4096

BOOTCONFIG_DIR="$(mktemp -d)"
BOOTCONFIG_INPUT="${BOOTCONFIG_DIR}/bootconfig.in"

# Bottlerocket has been experimentally shown to boot faster on EBS volumes when striping the root filesystem into 4MiB stripes.
# We use 4kb ext4 blocks. The stride and stripe should both be $STRIPE_SIZE / $EXT4_BLOCK_SIZE
ROOT_STRIDE=1024
ROOT_STRIPE_WIDTH=1024

case "${PARTITION_PLAN}" in
  split)
    truncate -s "${OS_IMAGE_SIZE_GIB}G" "${OS_IMAGE}"
    truncate -s "${DATA_IMAGE_SIZE_GIB}G" "${DATA_IMAGE}"
    ;;
  unified)
    truncate -s "$((OS_IMAGE_SIZE_GIB + DATA_IMAGE_SIZE_GIB))G" "${OS_IMAGE}"
    ;;
esac

declare -A partlabel parttype partguid partsize partoff
set_partition_sizes \
  "${OS_IMAGE_SIZE_GIB}" "${DATA_IMAGE_SIZE_GIB}" "${PARTITION_PLAN}" \
  partsize partoff
set_partition_labels partlabel
set_partition_types parttype
set_partition_uuids partguid "${PARTITION_PLAN}"

declare -a partargs
for part in \
  BIOS \
  EFI-A BOOT-A ROOT-A HASH-A RESERVED-A \
  EFI-B BOOT-B ROOT-B HASH-B RESERVED-B \
  PRIVATE DATA-A DATA-B ;
do
  # We create the DATA-B partition separately if we're using the split layout
  if [ "${part}" == "DATA-B" ] ; then
    continue
  fi

  # Each partition is aligned to a 1 MiB boundary, and extends to the sector
  # before the next partition starts. Specify the end point in sectors so we
  # can subtract a sector to fix the off-by-one error that comes from adding
  # start and size together. (1 MiB contains 2048 512-byte sectors.)
  part_start="${partoff[${part}]}"
  part_end="$((part_start + partsize[${part}]))"
  part_end="$((part_end * 2048 - 1))"

  partargs+=(-n "0:${part_start}M:${part_end}")
  partargs+=(-c "0:${partlabel[${part}]}")
  partargs+=(-t "0:${parttype[${part}]}")
  partargs+=(-u "0:${partguid[${part}]:-R}")

  # Boot partition attributes:
  #  48 = gptprio priority bit
  #  56 = gptprio successful bit
  case "${part}" in
    BOOT-A) partargs+=(-A 0:"set":48 -A 0:"set":56) ;;
    BOOT-B) partargs+=(-A 0:"clear":48 -A 0:"clear":56) ;;
  esac
done

sgdisk --clear "${partargs[@]}" --sort --print "${OS_IMAGE}"

# Partition the separate data disk, if we're using the split layout.
if [ "${PARTITION_PLAN}" == "split" ] ; then
  data_start="${partoff[DATA-B]}"
  data_end=$((data_start + partsize[DATA-B]))
  data_end=$((data_end * 2048 - 1))
  sgdisk --clear \
    -n "0:${data_start}M:${data_end}" \
    -c "0:${partlabel[DATA-B]}" \
    -t "0:${parttype[DATA-B]}" \
    -u "0:${partguid[DATA-B]}" \
    --sort --print "${DATA_IMAGE}"
fi

INSTALL_TIME="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
rpm -iv --ignorearch --root "${ROOT_MOUNT}" "${PACKAGE_DIR}"/*.rpm

# inventory installed packages
INVENTORY_QUERY="\{\"Name\":\"%{NAME}\"\
,\"Publisher\":\"Bottlerocket\"\
,\"Version\":\"${VERSION_ID}\"\
,\"Release\":\"${BUILD_ID}\"\
,\"InstalledTime\":\"${INSTALL_TIME}\"\
,\"ApplicationType\":\"%{GROUP}\"\
,\"Architecture\":\"%{ARCH}\"\
,\"Url\":\"%{URL}\"\
,\"Summary\":\"%{Summary}\"\}\n"

mapfile -t installed_rpms <<< "$(rpm -qa --root "${ROOT_MOUNT}" \
  --queryformat "${INVENTORY_QUERY}")"

# wrap installed_rpms mapfile into json
INVENTORY_DATA="$(jq --raw-output . <<<  "${installed_rpms[@]}")"
# remove the 'bottlerocket-' prefix from package names
INVENTORY_DATA="$(jq --arg PKG_PREFIX "bottlerocket-" \
                '(.Name) |= sub($PKG_PREFIX; "")' <<< "${INVENTORY_DATA}")"
# sort by package name and add 'Content' as top-level
INVENTORY_DATA="$(jq --slurp 'sort_by(.Name)' <<< "${INVENTORY_DATA}" | jq '{"Content": .}')"
printf "%s\n" "${INVENTORY_DATA}" > "${ROOT_MOUNT}/usr/share/bottlerocket/application-inventory.json"

# install licenses
mksquashfs \
  "${ROOT_MOUNT}"/usr/share/licenses \
  "${ROOT_MOUNT}"/usr/share/bottlerocket/licenses.squashfs \
  -no-exports -all-root -comp zstd
rm -rf "${ROOT_MOUNT}"/var/lib "${ROOT_MOUNT}"/usr/share/licenses/*

if [[ "${ARCH}" == "x86_64" ]]; then
  # MBR and BIOS-BOOT
  echo "(hd0) ${OS_IMAGE}" > "${ROOT_MOUNT}/boot/grub/device.map"
  "${ROOT_MOUNT}/sbin/grub-bios-setup" \
     --directory="${ROOT_MOUNT}/boot/grub" \
     --device-map="${ROOT_MOUNT}/boot/grub/device.map" \
     --root="hd0" \
     --skip-fs-probe \
     "${OS_IMAGE}"

  rm -vf "${ROOT_MOUNT}"/boot/grub/* "${ROOT_MOUNT}"/sbin/grub*
fi

# We also need an EFI partition, formatted FAT32 with the
# EFI binary at the correct path, e.g. /efi/boot. The grub
# package has placed the image in /boot/efi/EFI/BOOT.
mv "${ROOT_MOUNT}/boot/efi"/* "${EFI_MOUNT}"

# Do the setup required for `pesign` and `gpg` signing and
# verification to "just work" later on, regardless of which
# type of signing profile we have.
if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
  declare -a SHIM_SIGN_KEY
  declare -a CODE_SIGN_KEY

  # For an AWS profile, we expect a config file for the PKCS11
  # helper. Otherwise, there should be a local key and cert.
  if [ -s "${HOME}/.config/aws-kms-pkcs11/config.json" ] ; then
    # Set AWS environment variables from build secrets, if present.
    for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN ; do
      val="${var,,}"
      val="${HOME}/.aws/${val//_/-}.env"
      [ -s "${val}" ] || continue
      declare -x "${var}=$(cat "${val}")"
    done
    # Verify that AWS credentials are functional.
    aws sts get-caller-identity
    # Log all PKCS11 helper activity, to simplify debugging.
    export AWS_KMS_PKCS11_DEBUG=1
    SB_KEY_SOURCE="aws"
    SHIM_SIGN_KEY=(-c shim-sign-key -t shim-sign-key)
    CODE_SIGN_KEY=(-c code-sign-key -t code-sign-key)
  else
    # Disable the PKCS11 helper.
    rm /etc/pkcs11/modules/aws-kms-pkcs11.module

    # Generate the PKCS12 archives for import.
    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/shim-sign.key" \
      -in "${SBKEYS}/shim-sign.crt" \
      -certfile "${SBKEYS}/db.crt" \
      -out "${SBKEYS}/shim-sign.p12"

    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/code-sign.key" \
      -in "${SBKEYS}/code-sign.crt" \
      -certfile "${SBKEYS}/vendor.crt" \
      -out "${SBKEYS}/code-sign.p12"

    # Import certificates and private key archive.
    PEDB="/etc/pki/pesign"

    certutil -d "${PEDB}" -A -n db -i "${SBKEYS}/db.crt" -t ",,C"
    certutil -d "${PEDB}" -A -n shim-sign-key -i "${SBKEYS}/shim-sign.crt" -t ",,P"
    pk12util -d "${PEDB}" -i "${SBKEYS}/shim-sign.p12" -W ""

    certutil -d "${PEDB}" -A -n vendor -i "${SBKEYS}/vendor.crt" -t ",,C"
    certutil -d "${PEDB}" -A -n code-sign-key -i "${SBKEYS}/code-sign.crt" -t ",,P"
    pk12util -d "${PEDB}" -i "${SBKEYS}/code-sign.p12" -W ""

    certutil -d "${PEDB}" -L
    SB_KEY_SOURCE="local"
    SHIM_SIGN_KEY=(-c shim-sign-key)
    CODE_SIGN_KEY=(-c code-sign-key)
  fi

  # Convert certificates from PEM format (ASCII) to DER (binary). This could be
  # done when the certificates are created, but the resulting binary files are
  # not as nice to store in source control.
  for cert in PK KEK db vendor ; do
    openssl x509 \
      -inform PEM -in "${SBKEYS}/${cert}.crt" \
      -outform DER -out "${SBKEYS}/${cert}.cer"
  done

  # For signing the grub config, we need to embed the GPG public key in binary
  # form, which is similarly awkward to store in source control.
  gpg --import "${SBKEYS}/config-sign.key"
  if [ "${SB_KEY_SOURCE}" == "aws" ] ; then
    gpg --card-status
  fi
  gpg --export > "${SBKEYS}/config-sign.pubkey"
  gpg --list-keys
fi

pushd "${EFI_MOUNT}/EFI/BOOT" >/dev/null
shims=(boot*.efi)
shim="${shims[0]}"
grubs=(grub*.efi)
grub="${grubs[0]}"
mokms=(mm*.efi)
mokm="${mokms[0]}"
if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
  # Convert the vendor certificate to the expected format.
  cert_table "${SBKEYS}/vendor.cer" "${SBKEYS}/vendor.obj"

  # Replace the embedded vendor certificate, then sign shim with the db key.
  "${ARCH}-objdumpcopy" "${shim}" \
    --update-section ".vendor_cert=${SBKEYS}/vendor.obj"
  pesign -i "${shim}" -o "${shim}.signed" -s "${SHIM_SIGN_KEY[@]}"
  mv "${shim}.signed" "${shim}"
  pesigcheck -i "${shim}" -n 0 -c "${SBKEYS}/db.cer"

  # Sign the MOK manager as well.
  pesign -i "${mokm}" -o "${mokm}.signed" -s "${CODE_SIGN_KEY[@]}"
  mv "${mokm}.signed" "${mokm}"
  pesigcheck -i "${mokm}" -n 0 -c "${SBKEYS}/vendor.cer"

  # Replace the embedded gpg public key, then sign grub with the vendor key.
  "${ARCH}-objdumpcopy" "${grub}" \
    --file-alignment 4096 \
    --update-section ".pubkey=${SBKEYS}/config-sign.pubkey"
  pesign -i "${grub}" -o "${grub}.signed" -s "${CODE_SIGN_KEY[@]}"
  mv "${grub}.signed" "${grub}"
  pesigcheck -i "${grub}" -n 0 -c "${SBKEYS}/vendor.cer"
else
  # Generate a zero-sized certificate in the expected format.
  cert_table /dev/null "${SBKEYS}/vendor.obj"

  # Replace the embedded vendor certificate with the zero-sized one, which shim
  # will ignore when Secure Boot is disabled.
  "${ARCH}-objdumpcopy" "${shim}" \
    --update-section ".vendor_cert=${SBKEYS}/vendor.obj"

   # Remove the embedded gpg public key to disable GRUB's signature checks.
   "${ARCH}-objdumpcopy" "${grub}" \
     --file-alignment 4096 \
     --remove-section ".pubkey"
fi
popd >/dev/null

dd if=/dev/zero of="${EFI_IMAGE}" bs=1M count="${partsize[EFI-A]}"
mkfs.vfat -I -S 512 "${EFI_IMAGE}" $((partsize[EFI-A] * 1024))
mmd -i "${EFI_IMAGE}" ::/EFI
mmd -i "${EFI_IMAGE}" ::/EFI/BOOT
mcopy -i "${EFI_IMAGE}" "${EFI_MOUNT}/EFI/BOOT"/*.efi ::/EFI/BOOT
if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
  # Make the signing certificate available on the EFI system partition so it
  # can be imported through the firmware setup UI on bare metal systems.
  mcopy -i "${EFI_IMAGE}" "${SBKEYS}"/db.{crt,cer} ::/EFI/BOOT
fi
dd if="${EFI_IMAGE}" of="${OS_IMAGE}" conv=notrunc bs=1M seek="${partoff[EFI-A]}"

# Ensure that the grub directory exists.
mkdir -p "${ROOT_MOUNT}/boot/grub"

# Now that we're done messing with /, move /boot out of it
mv "${ROOT_MOUNT}/boot"/* "${BOOT_MOUNT}"

pushd "${BOOT_MOUNT}" >/dev/null

vmlinuz="vmlinuz"
if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
  pesign -i "${vmlinuz}" -o "${vmlinuz}.signed" -s "${CODE_SIGN_KEY[@]}"
  mv "${vmlinuz}.signed" "${vmlinuz}"
  pesigcheck -i "${vmlinuz}" -n 0 -c "${SBKEYS}/vendor.cer"
fi

# Generate an HMAC for the kernel after signing.
openssl sha512 -hmac FIPS-FTW-RHT2009 -hex "${vmlinuz}" \
  | awk -v vmlinuz="${vmlinuz}" '{ print $2 "  " vmlinuz }' \
  > ".${vmlinuz}.hmac"

popd >/dev/null

# Set the Bottlerocket variant, version, and build-id
SYS_ROOT="${ARCH}-bottlerocket-linux-gnu/sys-root"
VERSION="${VERSION_ID} (${VARIANT})"
cat <<EOF >> "${ROOT_MOUNT}/${SYS_ROOT}/usr/lib/os-release"
VERSION="${VERSION}"
PRETTY_NAME="${PRETTY_NAME} ${VERSION}"
VARIANT_ID=${VARIANT}
VERSION_ID=${VERSION_ID}
BUILD_ID=${BUILD_ID}
HOME_URL="https://github.com/bottlerocket-os/bottlerocket"
SUPPORT_URL="https://github.com/bottlerocket-os/bottlerocket/discussions"
BUG_REPORT_URL="https://github.com/bottlerocket-os/bottlerocket/issues"
DOCUMENTATION_URL="https://bottlerocket.dev"
EOF

# Set the BOTTLEROCKET-DATA Filesystem for creating/mounting
if [ "${XFS_DATA_PARTITION}" == "yes" ] ; then
  printf "%s\n" "DATA_PARTITION_FILESYSTEM=xfs" >> "${ROOT_MOUNT}/${SYS_ROOT}/usr/share/bottlerocket/image-features.env"
else
  printf "%s\n" "DATA_PARTITION_FILESYSTEM=ext4" >> "${ROOT_MOUNT}/${SYS_ROOT}/usr/share/bottlerocket/image-features.env"
fi

# BOTTLEROCKET-ROOT-A
mkdir -p "${ROOT_MOUNT}/lost+found"
ROOT_LABELS=$(setfiles -n -d -F -m -r "${ROOT_MOUNT}" \
    "${SELINUX_FILE_CONTEXTS}" "${ROOT_MOUNT}" \
    | awk -v root="${ROOT_MOUNT}" '{gsub(root"/","/"); gsub(root,"/"); print "ea_set", $1, "security.selinux", $4}')
mkfs.ext4 -E "lazy_itable_init=0,stride=${ROOT_STRIDE},stripe_width=${ROOT_STRIPE_WIDTH}" \
  -O ^has_journal -b "${VERITY_DATA_BLOCK_SIZE}" -d "${ROOT_MOUNT}" "${ROOT_IMAGE}" "${partsize[ROOT-A]}M"
echo "${ROOT_LABELS}" | debugfs -w -f - "${ROOT_IMAGE}"
resize2fs -M "${ROOT_IMAGE}"
dd if="${ROOT_IMAGE}" of="${OS_IMAGE}" conv=notrunc bs=1M seek="${partoff[ROOT-A]}"

# BOTTLEROCKET-VERITY-A
veritypart_mib="${partsize[HASH-A]}"
truncate -s "${veritypart_mib}M" "${VERITY_IMAGE}"
veritysetup_output="$(veritysetup format \
    --format "$VERITY_VERSION" \
    --hash "$VERITY_HASH_ALGORITHM" \
    --data-block-size "$VERITY_DATA_BLOCK_SIZE" \
    --hash-block-size "$VERITY_HASH_BLOCK_SIZE" \
    "${ROOT_IMAGE}" "${VERITY_IMAGE}" \
    | tee /dev/stderr)"
verityimage_size="$(stat -c %s "${VERITY_IMAGE}")"
veritypart_bytes="$((veritypart_mib * 1024 * 1024))"
if [ "${verityimage_size}" -gt "${veritypart_bytes}" ] ; then
    echo "verity content is larger than partition (${veritypart_mib}M)"
    exit 1
fi
VERITY_DATA_4K_BLOCKS="$(grep '^Data blocks:' <<<"${veritysetup_output}" | awk '{ print $NF }')"
VERITY_DATA_512B_BLOCKS="$((VERITY_DATA_4K_BLOCKS * 8))"
VERITY_ROOT_HASH="$(grep '^Root hash:' <<<"${veritysetup_output}" | awk '{ print $NF }')"
VERITY_SALT="$(grep '^Salt:' <<<"${veritysetup_output}" | awk '{ print $NF }')"
veritysetup verify "${ROOT_IMAGE}" "${VERITY_IMAGE}" "${VERITY_ROOT_HASH}"
dd if="${VERITY_IMAGE}" of="${OS_IMAGE}" conv=notrunc bs=1M seek="${partoff[HASH-A]}"

declare -a DM_VERITY_ROOT
DM_VERITY_ROOT=(
  "root,,,ro,0"
  "${VERITY_DATA_512B_BLOCKS}"
  "verity"
  "${VERITY_VERSION}"
  "PARTUUID=\$boot_uuid/PARTNROFF=1"
  "PARTUUID=\$boot_uuid/PARTNROFF=2"
  "${VERITY_DATA_BLOCK_SIZE}"
  "${VERITY_HASH_BLOCK_SIZE}"
  "${VERITY_DATA_4K_BLOCKS}"
  "1"
  "${VERITY_HASH_ALGORITHM}"
  "${VERITY_ROOT_HASH}"
  "${VERITY_SALT}"
  "2"
  "restart_on_corruption"
  "ignore_zero_blocks"
)

# write GRUB config
# If GRUB_SET_PRIVATE_VAR is set, include the parameters that support Boot Config
if [ "${GRUB_SET_PRIVATE_VAR}" == "yes" ] ; then
   BOOTCONFIG='bootconfig'
   INITRD="initrd (\$private)/bootconfig.data"
else
   BOOTCONFIG=""
   INITRD=""
fi

# If UEFI_SECURE_BOOT is set, disable interactive edits. Otherwise the intended
# kernel command line parameters could be changed if the boot fails. Disable
# signature checking as well, since grub.cfg will have already been verified
# before we reach this point. bootconfig.data is generated at runtime and can't
# be signed with a trusted key, so continuing to check signatures would prevent
# it from being read. If boot fails, trigger an automatic reboot, since nothing
# can be changed for troubleshooting purposes.
if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
   echo 'set superusers=""' > "${BOOT_MOUNT}/grub/grub.cfg"
   echo 'set check_signatures="no"' >> "${BOOT_MOUNT}/grub/grub.cfg"
   FALLBACK=$'   echo "rebooting in 30 seconds..."\n'
   FALLBACK+=$'   sleep 30\n'
   FALLBACK+=$'   reboot\n'
else
   FALLBACK=""
fi

cat <<EOF >> "${BOOT_MOUNT}/grub/grub.cfg"
set default="0"
set timeout="0"
set dm_verity_root="${DM_VERITY_ROOT[@]}"

menuentry "${PRETTY_NAME} ${VERSION_ID}" --unrestricted {
   linux (\$root)/vmlinuz \\
       ${KERNEL_PARAMETERS} \\
       ${BOOTCONFIG} \\
       root=/dev/dm-0 rootwait ro \\
       raid=noautodetect \\
       random.trust_cpu=on \\
       selinux=1 enforcing=1 \\
       dm-mod.create="\$dm_verity_root" \\
       -- \\
       systemd.log_target=journal-or-kmsg \\
       systemd.log_color=0 \\
       systemd.show_status=true
   ${INITRD}
   boot
   ${FALLBACK}
}
EOF

if [ "${UEFI_SECURE_BOOT}" == "yes" ] ; then
  gpg --detach-sign "${BOOT_MOUNT}/grub/grub.cfg"
  gpg --verify "${BOOT_MOUNT}/grub/grub.cfg.sig"
fi

# Combine any bootconfig snippets in /boot for later use, then clean up.
if [ -d "${BOOT_MOUNT}/boot-config.d" ] ; then
  find "${BOOT_MOUNT}/boot-config.d" -type f -mindepth 1 -maxdepth 1 -print0 \
    | sort -Vz | xargs -0 cat > "${BOOTCONFIG_INPUT}"
  rm -rf "${BOOT_MOUNT}/boot-config.d"
fi

# This should never happen, but if the image isn't using "grub-set-private-var"
# and we have some bootconfig input to render, then bail out because otherwise
# the kernel command line may not be configured as expected.
if [ -s "${BOOTCONFIG_INPUT}" ] && [ "${GRUB_SET_PRIVATE_VAR}" == "no" ] ; then
cat <<EOF >&2
Found bootconfig snippets but 'grub-set-private-var' isn't enabled for the variant.
To fix this, add the following to the variant's Cargo.toml:"
  [package.metadata.build-variant.image-features]
  grub-set-private-var = true
EOF
exit 1
fi

# Generate a no-op bootconfig if there weren't any snippets.
if [ ! -s  "${BOOTCONFIG_INPUT}" ] ; then
  echo -e "kernel {}\ninit {}" > "${BOOTCONFIG_INPUT}"
fi

# BOTTLEROCKET-BOOT-A
mkdir -p "${BOOT_MOUNT}/lost+found"
chmod -R go-rwx "${BOOT_MOUNT}"
BOOT_LABELS=$(setfiles -n -d -F -m -r "${BOOT_MOUNT}" \
    "${SELINUX_FILE_CONTEXTS}" "${BOOT_MOUNT}" \
  | awk -v root="${BOOT_MOUNT}" '{gsub(root"/","/"); gsub(root,"/"); print "ea_set", $1, "security.selinux", $4}')
mkfs.ext4 -O ^has_journal -d "${BOOT_MOUNT}" "${BOOT_IMAGE}" "${partsize[BOOT-A]}M"
echo "${BOOT_LABELS}" | debugfs -w -f - "${BOOT_IMAGE}"
resize2fs -M "${BOOT_IMAGE}"
dd if="${BOOT_IMAGE}" of="${OS_IMAGE}" conv=notrunc bs=1M seek="${partoff[BOOT-A]}"

# BOTTLEROCKET-PRIVATE

# Generate bootconfig file for the image.
touch "${PRIVATE_MOUNT}/bootconfig.data"
bootconfig -a "${BOOTCONFIG_INPUT}" "${PRIVATE_MOUNT}/bootconfig.data"

# Targeted toward the current API server implementation.
# Relative to the ext4 defaults, we:
# - adjust the inode ratio since we expect lots of small files
# - retain the inode size to allow most settings to be stored inline
# - retain the block size to handle worse-case alignment for hardware
mkfs.ext4 -b 4096 -i 4096 -I 256 -d "${PRIVATE_MOUNT}" "${PRIVATE_IMAGE}" "${partsize[PRIVATE]}M"
dd if="${PRIVATE_IMAGE}" of="${OS_IMAGE}" conv=notrunc bs=1M seek="${partoff[PRIVATE]}"

# BOTTLEROCKET-DATA-A and BOTTLEROCKET-DATA-B

# If we build on a host with SELinux enabled, we could end up with labels that
# do not match our policy. Since we allow replacing the data volume at runtime,
# we can't count on these labels being correct in any case, and it's better to
# remove them all.
UNLABELED=$(find "${DATA_MOUNT}" \
    | awk -v root="${DATA_MOUNT}" '{gsub(root"/","/"); gsub(root,"/"); print "ea_rm", $1, "security.selinux"}')


# Decide which data filesystem to create at build time based on layout.
#
# The DATA-A partition will always exist, but for the "split" layout, it will be
# too small to provide the desired filesystem parameters (inode count, etc) when
# it is grown later on. Hence this filesystem is only created for "unified".
#
# The DATA-B partition does not exist on the "unified" layout, which anticipates
# a single storage device. Hence this filesystem is only created for "split".
#
# If the other partition is available at runtime, the filesystem will be created
# during first boot instead, providing flexibility at the cost of a minor delay.
if [ "${XFS_DATA_PARTITION}" == "yes" ]; then
  mkfs_data_fn="mkfs_data_xfs"
else
  mkfs_data_fn="mkfs_data_ext4"
fi

case "${PARTITION_PLAN}" in
  unified)
    "${mkfs_data_fn}" "${OS_IMAGE}" "${partsize["DATA-A"]}M" "${partoff["DATA-A"]}" \
      "${BOTTLEROCKET_DATA}" "${DATA_MOUNT}" "${UNLABELED}"
    ;;
  split)
    "${mkfs_data_fn}" "${DATA_IMAGE}" "${partsize["DATA-B"]}M" "${partoff["DATA-B"]}" \
      "${BOTTLEROCKET_DATA}" "${DATA_MOUNT}" "${UNLABELED}"
    ;;
esac

sgdisk -v "${OS_IMAGE}"
[ -s "${DATA_IMAGE}" ] && sgdisk -v "${DATA_IMAGE}"
if [[ ${OUTPUT_FMT} == "raw" ]]; then
  lz4 -vc "${OS_IMAGE}" >"${OUTPUT_DIR}/${OS_IMAGE_NAME}.img.lz4"
  symlink_image "img.lz4" "os_image" \
    "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  if [ -s "${DATA_IMAGE}" ] ; then
    lz4 -vc "${DATA_IMAGE}" >"${OUTPUT_DIR}/${DATA_IMAGE_NAME}.img.lz4"
    symlink_image "img.lz4" "data_image" \
      "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  fi
elif [[ ${OUTPUT_FMT} == "qcow2" ]]; then
  qemu-img convert -f raw -O qcow2 "${OS_IMAGE}" "${OUTPUT_DIR}/${OS_IMAGE_NAME}.qcow2"
  symlink_image "qcow2" "os_image" \
    "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  if [ -s "${DATA_IMAGE}" ] ; then
    qemu-img convert -f raw -O qcow2 "${DATA_IMAGE}" "${OUTPUT_DIR}/${DATA_IMAGE_NAME}.qcow2"
    symlink_image "qcow2" "data_image" \
      "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  fi
elif [[ ${OUTPUT_FMT} == "vmdk" ]]; then
  # Stream optimization is required for creating an Open Virtual Appliance (OVA)
  qemu-img convert -f raw -O vmdk -o subformat=streamOptimized "${OS_IMAGE}" "${OUTPUT_DIR}/${OS_IMAGE_NAME}.vmdk"
  symlink_image "vmdk" "os_image" \
    "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  if [ -s "${DATA_IMAGE}" ] ; then
    qemu-img convert -f raw -O vmdk -o subformat=streamOptimized "${DATA_IMAGE}" "${OUTPUT_DIR}/${DATA_IMAGE_NAME}.vmdk"
    symlink_image "vmdk" "data_image" \
      "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
  fi
fi

# Now create the OVA if needed.
if [ "${OUTPUT_FMT}" == "vmdk" ] ; then
  generate_ova \
    "${OS_IMAGE_NAME}.vmdk" \
    "${DATA_IMAGE_NAME}.vmdk" \
    "${OS_IMAGE_PUBLISH_SIZE_GIB}" \
    "${DATA_IMAGE_PUBLISH_SIZE_GIB}" \
    "${OVF_TEMPLATE}" \
    "${UEFI_SECURE_BOOT}" \
    "${SBKEYS}" \
    "${OUTPUT_DIR}"
  symlink_image "ova" "os_image" \
    "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
fi

lz4 -9vc "${BOOT_IMAGE}" >"${OUTPUT_DIR}/${BOOT_IMAGE_NAME}"
lz4 -9vc "${VERITY_IMAGE}" >"${OUTPUT_DIR}/${VERITY_IMAGE_NAME}"
lz4 -9vc "${ROOT_IMAGE}" >"${OUTPUT_DIR}/${ROOT_IMAGE_NAME}"

symlink_image "" "boot_image" \
  "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
symlink_image "" "verity_image" \
  "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"
symlink_image "" "root_image" \
  "${SYMLINK_PREFIX}" "${VERSION_ID}" "${OUTPUT_DIR}"

find "${OUTPUT_DIR}" -type f -print -exec chown 1000:1000 {} \;

# Clean up temporary files to reduce size of layer.
rm -f "${PACKAGE_DIR}"/*.rpm
rm -rf /tmp/*
