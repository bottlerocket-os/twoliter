#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2154,SC2164,SC2312

# Store output artifacts in a versioned directory.
OUTPUT_DIR="${OUTPUT_DIR}/${VERSION_ID}-${BUILD_ID}"

FILENAME_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-${VERSION_ID}-${BUILD_ID}"
SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}"
VERSIONED_SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-${VERSION_ID}"
FRIENDLY_VERSIONED_SYMLINK_PREFIX="${IMAGE_NAME}-${VARIANT}-${ARCH}-v${VERSION_ID}"

OS_IMAGE_NAME="${FILENAME_PREFIX}"
OS_IMAGE_SYMLINK="${SYMLINK_PREFIX}"
OS_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}"
OS_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}"

DATA_IMAGE_NAME="${FILENAME_PREFIX}-data"
DATA_IMAGE_SYMLINK="${SYMLINK_PREFIX}-data"
DATA_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-data"
DATA_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-data"

BOOT_IMAGE_NAME="${FILENAME_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_SYMLINK="${SYMLINK_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-boot.ext4.lz4"
BOOT_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-boot.ext4.lz4"

VERITY_IMAGE_NAME="${FILENAME_PREFIX}-root.verity.lz4"
VERITY_IMAGE_SYMLINK="${SYMLINK_PREFIX}-root.verity.lz4"
VERITY_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-root.verity.lz4"
VERITY_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-root.verity.lz4"

ROOT_IMAGE_NAME="${FILENAME_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_SYMLINK="${SYMLINK_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_VERSIONED_SYMLINK="${VERSIONED_SYMLINK_PREFIX}-root.ext4.lz4"
ROOT_IMAGE_FRIENDLY_VERSIONED_SYMLINK="${FRIENDLY_VERSIONED_SYMLINK_PREFIX}-root.ext4.lz4"

CROSS_FACTORYDIR="/usr/share/factory"
CROSS_SYSCONFIGDIR="/etc"
CROSS_TMPFILESDIR="/usr/lib/tmpfiles.d"

CA_CERTS_BUNDLE="${HOME}/certs/ca-bundle.crt"
CA_CERTS_DEFAULT_BUNDLE="/usr/share/bottlerocket/ca-certificates/ca-bundle.crt"
CA_CERTS_DEFAULT_LICENSES="/usr/share/licenses/ca-certificates"
CA_CERTS_INSTALLDIR="${CROSS_FACTORYDIR}${CROSS_SYSCONFIGDIR}/pki/tls/certs"

SBKEYS="${HOME}/sbkeys"

VERITY_VERSION=1
VERITY_HASH_ALGORITHM=sha256
VERITY_DATA_BLOCK_SIZE=4096
VERITY_HASH_BLOCK_SIZE=4096

install_ca_certs() {
  local root_mount
  root_mount="${1:?}"
  install -d "${root_mount}${CA_CERTS_INSTALLDIR}"
  if [[ -s "${CA_CERTS_BUNDLE}" ]]; then
    install -p -m 0644 \
      "${CA_CERTS_BUNDLE}" \
      "${root_mount}${CA_CERTS_INSTALLDIR}"
  elif [[ -s "${CA_CERTS_DEFAULT_BUNDLE}" ]]; then
    install -p -m 0644 \
      "${CA_CERTS_DEFAULT_BUNDLE}" \
      "${root_mount}${CA_CERTS_INSTALLDIR}"
    install -p -m 0644 \
      -D "${CA_CERTS_DEFAULT_LICENSES}"/* \
      -t "${root_mount}/usr/share/licenses/ca-certificates"
  else
    echo "no CA certificates found" >&2
    exit 1
  fi
  mkdir -p "${root_mount}${CROSS_TMPFILESDIR}"
  cat <<EOF >>"${root_mount}${CROSS_TMPFILESDIR}/ca-certificates.conf"
C /etc/pki/tls/certs/ca-bundle.crt - - - -
L /etc/ssl/certs - - - - ../pki/tls/certs
EOF
}

# shim expects the following data structure in `.vendor_cert`:
#
# struct {
#   uint32_t vendor_authorized_size;
#   uint32_t vendor_deauthorized_size;
#   uint32_t vendor_authorized_offset;
#   uint32_t vendor_deauthorized_offset;
# } cert_table;
#
cert_table() {
  local input output size offset uint32_t
  input="${1:?}"
  output="${2:?}"
  size="$(stat -c %s "${input}")"
  rm -f "${output}"
  # The cert payload is offset by four 4-byte uint32_t values in the header.
  offset="$((4 * 4))"
  for n in "${size}" 0 "${offset}" "$((size + offset))"; do
    printf -v uint32_t '\\x%02x\\x%02x\\x%02x\\x%02x' \
      $((n & 255)) $((n >> 8 & 255)) $((n >> 16 & 255)) $((n >> 24 & 255))
    # shellcheck disable=SC2059  # Variable contains a pattern
    printf "${uint32_t}" >>"${output}"
  done
  cat "${input}" >>"${output}"
  # Zero-pad the output to the expected section size. Otherwise a subsequent
  # `objcopy` operation on the same section might fail to replace it, if the
  # new vendor certificate is larger than this one.
  truncate -s 4096 "${output}"
}

# Helper function to log the object layout before and after changes.
objdumpcopy() {
  local obj objdump objcopy
  obj="${1:?}"
  shift
  objdump="${ARCH}-bottlerocket-linux-gnu-objdump"
  objcopy="${ARCH}-bottlerocket-linux-gnu-objcopy"
  "${objdump}" -h "${obj}"
  "${objcopy}" "${@}" "${obj}"
  "${objdump}" -h "${obj}"
}

sbsetup() {
  local pedb sb_key_source
  local -n shim_sign_key code_sign_key
  shim_sign_key="${1:?}"
  code_sign_key="${2:?}"

  # For an AWS profile, we expect a config file for the PKCS11
  # helper. Otherwise, there should be a local key and cert.
  if [[ -s "${HOME}/.config/aws-kms-pkcs11/config.json" ]]; then
    # Set AWS environment variables from build secrets, if present.
    for var in AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN; do
      val="${var,,}"
      val="${HOME}/.aws/${val//_/-}.env"
      [[ -s "${val}" ]] || continue
      declare -x "${var}=$(cat "${val}")"
    done
    # Verify that AWS credentials are functional.
    aws sts get-caller-identity
    # Log all PKCS11 helper activity, to simplify debugging.
    export AWS_KMS_PKCS11_DEBUG=1
    sb_key_source="aws"
    shim_sign_key=(-c shim-sign-key -t shim-sign-key)
    code_sign_key=(-c code-sign-key -t code-sign-key)
  else
    # Disable the PKCS11 helper.
    rm /etc/pkcs11/modules/aws-kms-pkcs11.module

    # Generate the PKCS12 archives for import.
    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/shim-sign.key" \
      -in "${SBKEYS}/shim-sign.crt" \
      -certfile "${SBKEYS}/db.crt" \
      -out "${SBKEYS}/shim-sign.p12"

    openssl pkcs12 \
      -export \
      -passout pass: \
      -inkey "${SBKEYS}/code-sign.key" \
      -in "${SBKEYS}/code-sign.crt" \
      -certfile "${SBKEYS}/vendor.crt" \
      -out "${SBKEYS}/code-sign.p12"

    # Import certificates and private key archive.
    pedb="/etc/pki/pesign"

    certutil -d "${pedb}" -A -n db -i "${SBKEYS}/db.crt" -t ",,C"
    certutil -d "${pedb}" -A -n shim-sign-key -i "${SBKEYS}/shim-sign.crt" -t ",,P"
    pk12util -d "${pedb}" -i "${SBKEYS}/shim-sign.p12" -W ""

    certutil -d "${pedb}" -A -n vendor -i "${SBKEYS}/vendor.crt" -t ",,C"
    certutil -d "${pedb}" -A -n code-sign-key -i "${SBKEYS}/code-sign.crt" -t ",,P"
    pk12util -d "${pedb}" -i "${SBKEYS}/code-sign.p12" -W ""

    certutil -d "${pedb}" -L
    sb_key_source="local"
    shim_sign_key=(-c shim-sign-key)
    code_sign_key=(-c code-sign-key)
  fi

  # Convert certificates from PEM format (ASCII) to DER (binary). This could be
  # done when the certificates are created, but the resulting binary files are
  # not as nice to store in source control.
  for cert in PK KEK db vendor; do
    openssl x509 \
      -inform PEM -in "${SBKEYS}/${cert}.crt" \
      -outform DER -out "${SBKEYS}/${cert}.cer"
  done

  # For signing the grub config, we need to embed the GPG public key in binary
  # form, which is similarly awkward to store in source control.
  gpg --batch --no-tty --import "${SBKEYS}/config-sign.key"
  if [[ "${sb_key_source}" == "aws" ]]; then
    gpg --batch --no-tty --card-status
  fi
  gpg --batch --no-tty --export >"${SBKEYS}/config-sign.pubkey"
  gpg --batch --no-tty --list-keys
}

replace_vendor_certs() {
  local -n shim_sign_key code_sign_key
  local uefi_secure_boot
  shim_sign_key="${1:?}"
  code_sign_key="${2:?}"
  uefi_secure_boot="${3:?}"
  shims=(boot*.efi)
  shim="${shims[0]}"
  grubs=(grub*.efi)
  grub="${grubs[0]}"
  mokms=(mm*.efi)
  mokm="${mokms[0]}"
  if [[ "${uefi_secure_boot}" == "yes" ]]; then
    # Convert the vendor certificate to the expected format.
    cert_table "${SBKEYS}/vendor.cer" "${SBKEYS}/vendor.obj"

    # Replace the embedded vendor certificate, then sign shim with the db key.
    pesign -i "${shim}" -l
    objdumpcopy "${shim}" \
      --update-section ".vendor_cert=${SBKEYS}/vendor.obj"
    pesign -i "${shim}" -o "${shim}.signed" -s "${shim_sign_key[@]}"
    mv "${shim}.signed" "${shim}"
    pesign -i "${shim}" -l
    pesigcheck -i "${shim}" -n 0 -c "${SBKEYS}/db.cer"

    # Remove the original key if necessary, then sign the MOK manager as well.
    if [[ "$(pesign -i "${mokm}" -l)" == "No signatures found." ]]; then
      mv "${mokm}" "${mokm}.unsigned"
    else
      pesign -i "${mokm}" -o "${mokm}.unsigned" -u 0 -r
    fi
    pesign -i "${mokm}.unsigned" -o "${mokm}.signed" -s "${code_sign_key[@]}"
    mv "${mokm}.signed" "${mokm}"
    rm "${mokm}.unsigned"
    pesign -i "${mokm}" -l
    pesigcheck -i "${mokm}" -n 0 -c "${SBKEYS}/vendor.cer"

    # Remove the original vendor key if necessary, replace the embedded gpg
    # public key, then sign grub with the vendor key.
    if [[ "$(pesign -i "${grub}" -l)" == "No signatures found." ]]; then
      mv "${grub}" "${grub}.unsigned"
    else
      pesign -i "${grub}" -o "${grub}.unsigned" -u 0 -r
    fi
    objdumpcopy "${grub}.unsigned" \
      --file-alignment 4096 \
      --update-section ".pubkey=${SBKEYS}/config-sign.pubkey"
    pesign -i "${grub}.unsigned" -o "${grub}.signed" -s "${code_sign_key[@]}"
    mv "${grub}.signed" "${grub}"
    rm "${grub}.unsigned"
    pesign -i "${grub}" -l
    pesigcheck -i "${grub}" -n 0 -c "${SBKEYS}/vendor.cer"
  else
    # Generate a zero-sized certificate in the expected format.
    cert_table /dev/null "${SBKEYS}/vendor.obj"

    # Replace the embedded vendor certificate with the zero-sized one, which
    # shim will ignore when Secure Boot is disabled.
    objdumpcopy "${shim}" \
      --update-section ".vendor_cert=${SBKEYS}/vendor.obj"

    # Remove the embedded gpg public key to disable GRUB's signature checks.
    objdumpcopy "${grub}" \
      --file-alignment 4096 \
      --remove-section ".pubkey"
  fi
}

vmlinuzsetup() {
  local vmlinuz
  vmlinuz="${1:?}"
  if [[ "$(pesign -i "${vmlinuz}" -l)" == "No signatures found." ]]; then
    mv "${vmlinuz}" "${vmlinuz}.unsigned"
  else
    pesign -i "${vmlinuz}" -o "${vmlinuz}.unsigned" -u 0 -r
  fi
  pesign -i "${vmlinuz}.unsigned" -o "${vmlinuz}.signed" -s "${code_sign_key[@]}"
  mv "${vmlinuz}.signed" "${vmlinuz}"
  rm "${vmlinuz}.unsigned"
  pesign -i "${vmlinuz}" -l
  pesigcheck -i "${vmlinuz}" -n 0 -c "${SBKEYS}/vendor.cer"
}

vmlinuzhmac(){
  local vmlinuz
  vmlinuz="${1:?}"
  openssl sha512 -hmac FIPS-FTW-RHT2009 -hex "${vmlinuz}" \
  | awk -v vmlinuz="${vmlinuz}" '{ print $2 "  " vmlinuz }' \
  > ".${vmlinuz}.hmac"
}

sign_grub(){
  local grub_cfg
  grub_cfg="${1:?}"
  gpg --batch --no-tty --detach-sign "${grub_cfg}"
  gpg --batch --no-tty --verify "${grub_cfg}.sig" "${grub_cfg}"
}

veritysetup_format() {
  local root_image verity_image
  root_image="${1:?}"
  verity_image="${2:?}"
  veritysetup format \
    --format "${VERITY_VERSION}" \
    --hash "${VERITY_HASH_ALGORITHM}" \
    --data-block-size "${VERITY_DATA_BLOCK_SIZE}" \
    --hash-block-size "${VERITY_HASH_BLOCK_SIZE}" \
    "${root_image}" "${verity_image}" |
    tee /dev/stderr
}

generate_ovf() {
  local os_image_publish_size_gib data_image_publish_size_gib
  local ovf_template uefi_secure_boot
  os_image_publish_size_gib="${1:?}"
  data_image_publish_size_gib="${2:?}"
  ovf_template="${3:?}"
  uefi_secure_boot="${4:?}"

  os_vmdk="${OS_IMAGE_NAME}.vmdk"
  data_vmdk="${DATA_IMAGE_NAME}.vmdk"
  ovf="${OS_IMAGE_NAME}.ovf"
  ova_dir="$(mktemp -d)"

  # The manifest expects disk sizes in bytes.
  bytes_in_gib="$((1024 * 1024 * 1024))"
  os_disk_bytes="$((os_image_publish_size_gib * bytes_in_gib))"
  data_disk_bytes="$((data_image_publish_size_gib * bytes_in_gib))"
  sed "${ovf_template}" \
     -e "s/{{OS_DISK}}/${os_vmdk}/g" \
     -e "s/{{DATA_DISK}}/${data_vmdk}/g" \
     -e "s/{{OS_DISK_BYTES}}/${os_disk_bytes}/g" \
     -e "s/{{DATA_DISK_BYTES}}/${data_disk_bytes}/g" \
     > "${ova_dir}/${ovf}"

  # The manifest templates for Secure Boot expect the cert data for
  # PK, KEK, db, and dbx.
  if [[ "${uefi_secure_boot}" == "yes" ]] ; then
    pk_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${SBKEYS}/PK.cer")"
    kek_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${SBKEYS}/KEK.cer")"
    db_cert_der_hex="$(hexdump -ve '1/1 "%02x"' "${SBKEYS}/db.cer")"
    dbx_empty_hash_hex="$(sha256sum /dev/null | awk '{ print $1 }')"
    sed -i \
      -e "s/{{PK_CERT_DER_HEX}}/${pk_cert_der_hex}/g" \
      -e "s/{{KEK_CERT_DER_HEX}}/${kek_cert_der_hex}/g" \
      -e "s/{{DB_CERT_DER_HEX}}/${db_cert_der_hex}/g" \
      -e "s/{{DBX_EMPTY_HASH_HEX}}/${dbx_empty_hash_hex}/g" \
      "${ova_dir}/${ovf}"
  fi

  # Make sure we replaced all the '{{...}}' fields with real values.
  if grep -F -e '{{' -e '}}' "${ova_dir}/${ovf}" ; then
    echo "Failed to fully render the OVF template" >&2
    exit 1
  fi

  # Create the manifest file with the hashes of the VMDKs and the OVF.
  manifest="${OS_IMAGE_NAME}.mf"
  pushd "${OUTPUT_DIR}" >/dev/null
  os_sha256="$(sha256sum "${os_vmdk}" | awk '{print $1}')"
  echo "SHA256(${os_vmdk})= ${os_sha256}" > "${ova_dir}/${manifest}"
  if [[ -s "${data_vmdk}" ]] ; then
    data_sha256="$(sha256sum "${data_vmdk}" | awk '{print $1}')"
    echo "SHA256(${data_vmdk})= ${data_sha256}" >> "${ova_dir}/${manifest}"
  fi
  popd >/dev/null
  pushd "${ova_dir}" >/dev/null
  ovf_sha256="$(sha256sum "${ovf}" | awk '{print $1}')"
  echo "SHA256(${ovf})= ${ovf_sha256}" >> "${manifest}"
  popd >/dev/null

  # According to the OVF spec:
  # https://www.dmtf.org/sites/default/files/standards/documents/DSP0243_2.1.1.pdf,
  # the OVF must be first in the tar bundle.  Manifest is next, and then the
  # files must fall in the same order as listed in the References section of the
  # OVF file
  ova="${OS_IMAGE_NAME}.ova"
  tar -cf "${OUTPUT_DIR}/${ova}" -C "${ova_dir}" "${ovf}" "${manifest}"
  tar -rf "${OUTPUT_DIR}/${ova}" -C "${OUTPUT_DIR}" "${os_vmdk}"
  if [[ -s "${data_vmdk}" ]] ; then
     tar -rf "${OUTPUT_DIR}/${ova}" -C "${OUTPUT_DIR}" "${data_vmdk}"
  fi

  symlink_image "ova" "os_image"
  rm -rf "${ova_dir}"
}

symlink_image() {
  local ext what
  ext="${1}"
  what="${2}"
  ext="${ext:+.$ext}"
  target="${what^^}_NAME"
  for link in symlink versioned_symlink friendly_versioned_symlink; do
    link="${what^^}_${link^^}"
    ln -sf "${!target}${ext}" "${OUTPUT_DIR}/${!link}${ext}"
  done
}
